// Code generated by lazyproto. DO NOT EDIT.
// source: logs.proto

package simple

import (
	"fmt"
	"sync"
	"unsafe"

	"github.com/tigrannajaryan/exp-lazyproto"
	"github.com/tigrannajaryan/exp-lazyproto/internal/oneof"
	"github.com/tigrannajaryan/exp-lazyproto/internal/protomessage"

	"github.com/tigrannajaryan/exp-lazyproto/internal/molecule"
	"github.com/tigrannajaryan/exp-lazyproto/internal/molecule/src/codec"
)

var _ = oneof.OneOf{}       // To avoid unused import warning.
var _ = unsafe.Pointer(nil) // To avoid unused import warning.
var _ = fmt.Errorf          // To avoid unused import warning.

// SeverityNumber values
type SeverityNumber uint32

const (
	// SeverityNumber is not specified
	SeverityNumber_SEVERITY_NUMBER_UNSPECIFIED SeverityNumber = 0
	SeverityNumber_SEVERITY_NUMBER_TRACE       SeverityNumber = 1
	SeverityNumber_SEVERITY_NUMBER_TRACE2      SeverityNumber = 2
	SeverityNumber_SEVERITY_NUMBER_TRACE3      SeverityNumber = 3
	SeverityNumber_SEVERITY_NUMBER_TRACE4      SeverityNumber = 4
	SeverityNumber_SEVERITY_NUMBER_DEBUG       SeverityNumber = 5
	SeverityNumber_SEVERITY_NUMBER_DEBUG2      SeverityNumber = 6
	SeverityNumber_SEVERITY_NUMBER_DEBUG3      SeverityNumber = 7
	SeverityNumber_SEVERITY_NUMBER_DEBUG4      SeverityNumber = 8
	SeverityNumber_SEVERITY_NUMBER_INFO        SeverityNumber = 9
	SeverityNumber_SEVERITY_NUMBER_INFO2       SeverityNumber = 10
	SeverityNumber_SEVERITY_NUMBER_INFO3       SeverityNumber = 11
	SeverityNumber_SEVERITY_NUMBER_INFO4       SeverityNumber = 12
	SeverityNumber_SEVERITY_NUMBER_WARN        SeverityNumber = 13
	SeverityNumber_SEVERITY_NUMBER_WARN2       SeverityNumber = 14
	SeverityNumber_SEVERITY_NUMBER_WARN3       SeverityNumber = 15
	SeverityNumber_SEVERITY_NUMBER_WARN4       SeverityNumber = 16
	SeverityNumber_SEVERITY_NUMBER_ERROR       SeverityNumber = 17
	SeverityNumber_SEVERITY_NUMBER_ERROR2      SeverityNumber = 18
	SeverityNumber_SEVERITY_NUMBER_ERROR3      SeverityNumber = 19
	SeverityNumber_SEVERITY_NUMBER_ERROR4      SeverityNumber = 20
	SeverityNumber_SEVERITY_NUMBER_FATAL       SeverityNumber = 21
	SeverityNumber_SEVERITY_NUMBER_FATAL2      SeverityNumber = 22
	SeverityNumber_SEVERITY_NUMBER_FATAL3      SeverityNumber = 23
	SeverityNumber_SEVERITY_NUMBER_FATAL4      SeverityNumber = 24
)

// ====================== LogsData message implementation ======================

// LogsData contains all log data
type LogsData struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_LogsData

	// List of ResourceLogs
	resourceLogs []*ResourceLogs
}

func UnmarshalLogsData(bytes []byte, opts lazyproto.UnmarshalOpts) (*LogsData, error) {
	if opts.WithValidate {
		if err := validateLogsData(bytes); err != nil {
			return nil, err
		}
	}

	m := logsDataPool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *LogsData) Free() {
	logsDataPool.Release(m)
}

// flags_LogsData is the type of the bit flags.
type flags_LogsData uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_LogsData_ResourceLogs_Decoded flags_LogsData = 0x1

// ResourceLogs returns the value of the resourceLogs.
func (m *LogsData) ResourceLogs() (r []*ResourceLogs) {
	if m._flags&flags_LogsData_ResourceLogs_Decoded == 0 {
		m.decodeResourceLogs()
	}
	return m.resourceLogs
}

// This is noinline, so that ResourceLogs() is inlined instead.
//go:noinline
func (m *LogsData) decodeResourceLogs() {
	// Decode nested message(s).
	for i := range m.resourceLogs {
		// TODO: decide how to handle decoding errors.
		_ = m.resourceLogs[i].decode()
	}
	m._flags |= flags_LogsData_ResourceLogs_Decoded
}

// SetResourceLogs sets the value of the resourceLogs.
func (m *LogsData) SetResourceLogs(v []*ResourceLogs) {
	m.resourceLogs = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.resourceLogs {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *LogsData) ResourceLogsRemoveIf(f func(*ResourceLogs) bool) {
	// Call getter to load the field.
	m.ResourceLogs()

	newLen := 0
	for i := 0; i < len(m.resourceLogs); i++ {
		if f(m.resourceLogs[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.resourceLogs[newLen] != nil {
			m.resourceLogs[newLen].Free()
		}
		m.resourceLogs[newLen] = m.resourceLogs[i]
		m.resourceLogs[i] = nil
		newLen++
	}
	if newLen != len(m.resourceLogs) {
		m.resourceLogs = m.resourceLogs[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

func validateLogsData(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resourceLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateResourceLogs(v)
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *LogsData) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	resourceLogsCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resourceLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			resourceLogsCount++
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.resourceLogs) < resourceLogsCount {
		// Need new space.
		m.resourceLogs = make([]*ResourceLogs, resourceLogsCount)
	} else {
		// Existing capacity is enough.
		m.resourceLogs = m.resourceLogs[0:resourceLogsCount]
	}
	resourceLogsPool.GetSlice(m.resourceLogs)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	resourceLogsCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resourceLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.resourceLogs[resourceLogsCount]
			resourceLogsCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_LogsData_ResourceLogs = molecule.PrepareEmbeddedField(1)

func (m *LogsData) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "resourceLogs".
		for _, elem := range m.resourceLogs {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_LogsData_ResourceLogs)
		}
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of LogsData structs.
type logsDataPoolType struct {
	pool []*LogsData
	mux  sync.Mutex
}

var logsDataPool = logsDataPoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *logsDataPoolType) Get() *LogsData {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &LogsData{}
}

func (p *logsDataPoolType) GetSlice(r []*LogsData) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]LogsData, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *logsDataPoolType) ReleaseSlice(slice []*LogsData) {
	for _, elem := range slice {
		// Release nested resourceLogs recursively to their pool.
		resourceLogsPool.ReleaseSlice(elem.resourceLogs)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.resourceLogs = elem.resourceLogs[:0]
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *logsDataPoolType) Release(elem *LogsData) {
	// Release nested resourceLogs recursively to their pool.
	resourceLogsPool.ReleaseSlice(elem.resourceLogs)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.resourceLogs = elem.resourceLogs[:0]

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== ResourceLogs message implementation ======================

type ResourceLogs struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_ResourceLogs

	// The Resource
	resource *Resource

	// List of ScopeLogs
	scopeLogs []*ScopeLogs
	schemaUrl string
}

func UnmarshalResourceLogs(bytes []byte, opts lazyproto.UnmarshalOpts) (*ResourceLogs, error) {
	if opts.WithValidate {
		if err := validateResourceLogs(bytes); err != nil {
			return nil, err
		}
	}

	m := resourceLogsPool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ResourceLogs) Free() {
	resourceLogsPool.Release(m)
}

// flags_ResourceLogs is the type of the bit flags.
type flags_ResourceLogs uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_ResourceLogs_Resource_Decoded flags_ResourceLogs = 0x1
const flags_ResourceLogs_ScopeLogs_Decoded flags_ResourceLogs = 0x2

// Resource returns the value of the resource.
func (m *ResourceLogs) Resource() (r *Resource) {
	if m._flags&flags_ResourceLogs_Resource_Decoded == 0 {
		m.decodeResource()
	}
	return m.resource
}

// This is noinline, so that Resource() is inlined instead.
//go:noinline
func (m *ResourceLogs) decodeResource() {
	// Decode nested message(s).
	resource := m.resource
	if resource != nil {
		// TODO: decide how to handle decoding errors.
		_ = resource.decode()
	}
	m._flags |= flags_ResourceLogs_Resource_Decoded
}

// SetResource sets the value of the resource.
func (m *ResourceLogs) SetResource(v *Resource) {
	m.resource = v

	// Make sure the field's Parent points to this message.
	v._protoMessage.Parent = &m._protoMessage

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// ScopeLogs returns the value of the scopeLogs.
func (m *ResourceLogs) ScopeLogs() (r []*ScopeLogs) {
	if m._flags&flags_ResourceLogs_ScopeLogs_Decoded == 0 {
		m.decodeScopeLogs()
	}
	return m.scopeLogs
}

// This is noinline, so that ScopeLogs() is inlined instead.
//go:noinline
func (m *ResourceLogs) decodeScopeLogs() {
	// Decode nested message(s).
	for i := range m.scopeLogs {
		// TODO: decide how to handle decoding errors.
		_ = m.scopeLogs[i].decode()
	}
	m._flags |= flags_ResourceLogs_ScopeLogs_Decoded
}

// SetScopeLogs sets the value of the scopeLogs.
func (m *ResourceLogs) SetScopeLogs(v []*ScopeLogs) {
	m.scopeLogs = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.scopeLogs {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *ResourceLogs) ScopeLogsRemoveIf(f func(*ScopeLogs) bool) {
	// Call getter to load the field.
	m.ScopeLogs()

	newLen := 0
	for i := 0; i < len(m.scopeLogs); i++ {
		if f(m.scopeLogs[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.scopeLogs[newLen] != nil {
			m.scopeLogs[newLen].Free()
		}
		m.scopeLogs[newLen] = m.scopeLogs[i]
		m.scopeLogs[i] = nil
		newLen++
	}
	if newLen != len(m.scopeLogs) {
		m.scopeLogs = m.scopeLogs[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

// SchemaUrl returns the value of the schemaUrl.
func (m *ResourceLogs) SchemaUrl() (r string) {
	return m.schemaUrl
}

// SetSchemaUrl sets the value of the schemaUrl.
func (m *ResourceLogs) SetSchemaUrl(v string) {
	m.schemaUrl = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateResourceLogs(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resource), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateResource(v)
			if err != nil {
				return err
			}
		case 0b0_0010_010: // field number 2 (scopeLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateScopeLogs(v)
			if err != nil {
				return err
			}
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *ResourceLogs) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	scopeLogsCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resource), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_0010_010: // field number 2 (scopeLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			scopeLogsCount++
			buf.SkipRawBytes()
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.scopeLogs) < scopeLogsCount {
		// Need new space.
		m.scopeLogs = make([]*ScopeLogs, scopeLogsCount)
	} else {
		// Existing capacity is enough.
		m.scopeLogs = m.scopeLogs[0:scopeLogsCount]
	}
	scopeLogsPool.GetSlice(m.scopeLogs)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	scopeLogsCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (resource), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			m.resource = resourcePool.Get()
			m.resource._protoMessage.Parent = &m._protoMessage
			m.resource._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0010_010: // field number 2 (scopeLogs), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.scopeLogs[scopeLogsCount]
			scopeLogsCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.schemaUrl = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_ResourceLogs_Resource = molecule.PrepareEmbeddedField(1)
var prepared_ResourceLogs_ScopeLogs = molecule.PrepareEmbeddedField(2)
var prepared_ResourceLogs_SchemaUrl = molecule.PrepareStringField(3)

func (m *ResourceLogs) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "resource".
		resource := m.resource
		if resource != nil {
			token := ps.BeginEmbedded()
			if err := resource.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_ResourceLogs_Resource)
		}
		// Marshal "scopeLogs".
		for _, elem := range m.scopeLogs {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_ResourceLogs_ScopeLogs)
		}
		// Marshal "schemaUrl".
		ps.StringPrepared(prepared_ResourceLogs_SchemaUrl, m.schemaUrl)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of ResourceLogs structs.
type resourceLogsPoolType struct {
	pool []*ResourceLogs
	mux  sync.Mutex
}

var resourceLogsPool = resourceLogsPoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *resourceLogsPoolType) Get() *ResourceLogs {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &ResourceLogs{}
}

func (p *resourceLogsPoolType) GetSlice(r []*ResourceLogs) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]ResourceLogs, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *resourceLogsPoolType) ReleaseSlice(slice []*ResourceLogs) {
	for _, elem := range slice {
		// Release nested resource recursively to their pool.
		if elem.resource != nil {
			resourcePool.Release(elem.resource)
		}
		// Release nested scopeLogs recursively to their pool.
		scopeLogsPool.ReleaseSlice(elem.scopeLogs)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.resource = nil
		elem.scopeLogs = elem.scopeLogs[:0]
		elem.schemaUrl = ""
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *resourceLogsPoolType) Release(elem *ResourceLogs) {
	// Release nested resource recursively to their pool.
	if elem.resource != nil {
		resourcePool.Release(elem.resource)
	}
	// Release nested scopeLogs recursively to their pool.
	scopeLogsPool.ReleaseSlice(elem.scopeLogs)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.resource = nil
	elem.scopeLogs = elem.scopeLogs[:0]
	elem.schemaUrl = ""

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== Resource message implementation ======================

type Resource struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_Resource

	attributes             []*KeyValue
	droppedAttributesCount uint32
}

func UnmarshalResource(bytes []byte, opts lazyproto.UnmarshalOpts) (*Resource, error) {
	if opts.WithValidate {
		if err := validateResource(bytes); err != nil {
			return nil, err
		}
	}

	m := resourcePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *Resource) Free() {
	resourcePool.Release(m)
}

// flags_Resource is the type of the bit flags.
type flags_Resource uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_Resource_Attributes_Decoded flags_Resource = 0x1

// Attributes returns the value of the attributes.
func (m *Resource) Attributes() (r []*KeyValue) {
	if m._flags&flags_Resource_Attributes_Decoded == 0 {
		m.decodeAttributes()
	}
	return m.attributes
}

// This is noinline, so that Attributes() is inlined instead.
//go:noinline
func (m *Resource) decodeAttributes() {
	// Decode nested message(s).
	for i := range m.attributes {
		// TODO: decide how to handle decoding errors.
		_ = m.attributes[i].decode()
	}
	m._flags |= flags_Resource_Attributes_Decoded
}

// SetAttributes sets the value of the attributes.
func (m *Resource) SetAttributes(v []*KeyValue) {
	m.attributes = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.attributes {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *Resource) AttributesRemoveIf(f func(*KeyValue) bool) {
	// Call getter to load the field.
	m.Attributes()

	newLen := 0
	for i := 0; i < len(m.attributes); i++ {
		if f(m.attributes[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.attributes[newLen] != nil {
			m.attributes[newLen].Free()
		}
		m.attributes[newLen] = m.attributes[i]
		m.attributes[i] = nil
		newLen++
	}
	if newLen != len(m.attributes) {
		m.attributes = m.attributes[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

// DroppedAttributesCount returns the value of the droppedAttributesCount.
func (m *Resource) DroppedAttributesCount() (r uint32) {
	return m.droppedAttributesCount
}

// SetDroppedAttributesCount sets the value of the droppedAttributesCount.
func (m *Resource) SetDroppedAttributesCount(v uint32) {
	m.droppedAttributesCount = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateResource(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateKeyValue(v)
			if err != nil {
				return err
			}
		case 0b0_0010_000: // field number 2 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			_, err := buf.AsUint32()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *Resource) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	attributesCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			attributesCount++
			buf.SkipRawBytes()
		case 0b0_0010_000: // field number 2 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			buf.SkipVarint()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.attributes) < attributesCount {
		// Need new space.
		m.attributes = make([]*KeyValue, attributesCount)
	} else {
		// Existing capacity is enough.
		m.attributes = m.attributes[0:attributesCount]
	}
	keyValuePool.GetSlice(m.attributes)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	attributesCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.attributes[attributesCount]
			attributesCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0010_000: // field number 2 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsUint32()
			if err != nil {
				return err
			}
			m.droppedAttributesCount = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_Resource_Attributes = molecule.PrepareEmbeddedField(1)
var prepared_Resource_DroppedAttributesCount = molecule.PrepareUint32Field(2)

func (m *Resource) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "attributes".
		for _, elem := range m.attributes {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_Resource_Attributes)
		}
		// Marshal "droppedAttributesCount".
		ps.Uint32Prepared(prepared_Resource_DroppedAttributesCount, m.droppedAttributesCount)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of Resource structs.
type resourcePoolType struct {
	pool []*Resource
	mux  sync.Mutex
}

var resourcePool = resourcePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *resourcePoolType) Get() *Resource {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &Resource{}
}

func (p *resourcePoolType) GetSlice(r []*Resource) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]Resource, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *resourcePoolType) ReleaseSlice(slice []*Resource) {
	for _, elem := range slice {
		// Release nested attributes recursively to their pool.
		keyValuePool.ReleaseSlice(elem.attributes)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.attributes = elem.attributes[:0]
		elem.droppedAttributesCount = 0
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *resourcePoolType) Release(elem *Resource) {
	// Release nested attributes recursively to their pool.
	keyValuePool.ReleaseSlice(elem.attributes)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.attributes = elem.attributes[:0]
	elem.droppedAttributesCount = 0

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== ScopeLogs message implementation ======================

// A collection of Logs produced by a Scope.
type ScopeLogs struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_ScopeLogs

	scope *InstrumentationScope

	// A list of log records.
	logRecords []*LogRecord

	// This schema_url applies to all logs in the "logs" field.
	schemaUrl string
}

func UnmarshalScopeLogs(bytes []byte, opts lazyproto.UnmarshalOpts) (*ScopeLogs, error) {
	if opts.WithValidate {
		if err := validateScopeLogs(bytes); err != nil {
			return nil, err
		}
	}

	m := scopeLogsPool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ScopeLogs) Free() {
	scopeLogsPool.Release(m)
}

// flags_ScopeLogs is the type of the bit flags.
type flags_ScopeLogs uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_ScopeLogs_Scope_Decoded flags_ScopeLogs = 0x1
const flags_ScopeLogs_LogRecords_Decoded flags_ScopeLogs = 0x2

// Scope returns the value of the scope.
func (m *ScopeLogs) Scope() (r *InstrumentationScope) {
	if m._flags&flags_ScopeLogs_Scope_Decoded == 0 {
		m.decodeScope()
	}
	return m.scope
}

// This is noinline, so that Scope() is inlined instead.
//go:noinline
func (m *ScopeLogs) decodeScope() {
	// Decode nested message(s).
	scope := m.scope
	if scope != nil {
		// TODO: decide how to handle decoding errors.
		_ = scope.decode()
	}
	m._flags |= flags_ScopeLogs_Scope_Decoded
}

// SetScope sets the value of the scope.
func (m *ScopeLogs) SetScope(v *InstrumentationScope) {
	m.scope = v

	// Make sure the field's Parent points to this message.
	v._protoMessage.Parent = &m._protoMessage

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// LogRecords returns the value of the logRecords.
func (m *ScopeLogs) LogRecords() (r []*LogRecord) {
	if m._flags&flags_ScopeLogs_LogRecords_Decoded == 0 {
		m.decodeLogRecords()
	}
	return m.logRecords
}

// This is noinline, so that LogRecords() is inlined instead.
//go:noinline
func (m *ScopeLogs) decodeLogRecords() {
	// Decode nested message(s).
	for i := range m.logRecords {
		// TODO: decide how to handle decoding errors.
		_ = m.logRecords[i].decode()
	}
	m._flags |= flags_ScopeLogs_LogRecords_Decoded
}

// SetLogRecords sets the value of the logRecords.
func (m *ScopeLogs) SetLogRecords(v []*LogRecord) {
	m.logRecords = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.logRecords {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *ScopeLogs) LogRecordsRemoveIf(f func(*LogRecord) bool) {
	// Call getter to load the field.
	m.LogRecords()

	newLen := 0
	for i := 0; i < len(m.logRecords); i++ {
		if f(m.logRecords[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.logRecords[newLen] != nil {
			m.logRecords[newLen].Free()
		}
		m.logRecords[newLen] = m.logRecords[i]
		m.logRecords[i] = nil
		newLen++
	}
	if newLen != len(m.logRecords) {
		m.logRecords = m.logRecords[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

// SchemaUrl returns the value of the schemaUrl.
func (m *ScopeLogs) SchemaUrl() (r string) {
	return m.schemaUrl
}

// SetSchemaUrl sets the value of the schemaUrl.
func (m *ScopeLogs) SetSchemaUrl(v string) {
	m.schemaUrl = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateScopeLogs(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (scope), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateInstrumentationScope(v)
			if err != nil {
				return err
			}
		case 0b0_0010_010: // field number 2 (logRecords), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateLogRecord(v)
			if err != nil {
				return err
			}
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *ScopeLogs) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	logRecordsCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (scope), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_0010_010: // field number 2 (logRecords), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			logRecordsCount++
			buf.SkipRawBytes()
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.logRecords) < logRecordsCount {
		// Need new space.
		m.logRecords = make([]*LogRecord, logRecordsCount)
	} else {
		// Existing capacity is enough.
		m.logRecords = m.logRecords[0:logRecordsCount]
	}
	logRecordPool.GetSlice(m.logRecords)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	logRecordsCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (scope), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			m.scope = instrumentationScopePool.Get()
			m.scope._protoMessage.Parent = &m._protoMessage
			m.scope._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0010_010: // field number 2 (logRecords), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.logRecords[logRecordsCount]
			logRecordsCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0011_010: // field number 3 (schemaUrl), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.schemaUrl = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_ScopeLogs_Scope = molecule.PrepareEmbeddedField(1)
var prepared_ScopeLogs_LogRecords = molecule.PrepareEmbeddedField(2)
var prepared_ScopeLogs_SchemaUrl = molecule.PrepareStringField(3)

func (m *ScopeLogs) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "scope".
		scope := m.scope
		if scope != nil {
			token := ps.BeginEmbedded()
			if err := scope.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_ScopeLogs_Scope)
		}
		// Marshal "logRecords".
		for _, elem := range m.logRecords {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_ScopeLogs_LogRecords)
		}
		// Marshal "schemaUrl".
		ps.StringPrepared(prepared_ScopeLogs_SchemaUrl, m.schemaUrl)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of ScopeLogs structs.
type scopeLogsPoolType struct {
	pool []*ScopeLogs
	mux  sync.Mutex
}

var scopeLogsPool = scopeLogsPoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *scopeLogsPoolType) Get() *ScopeLogs {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &ScopeLogs{}
}

func (p *scopeLogsPoolType) GetSlice(r []*ScopeLogs) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]ScopeLogs, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *scopeLogsPoolType) ReleaseSlice(slice []*ScopeLogs) {
	for _, elem := range slice {
		// Release nested scope recursively to their pool.
		if elem.scope != nil {
			instrumentationScopePool.Release(elem.scope)
		}
		// Release nested logRecords recursively to their pool.
		logRecordPool.ReleaseSlice(elem.logRecords)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.scope = nil
		elem.logRecords = elem.logRecords[:0]
		elem.schemaUrl = ""
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *scopeLogsPoolType) Release(elem *ScopeLogs) {
	// Release nested scope recursively to their pool.
	if elem.scope != nil {
		instrumentationScopePool.Release(elem.scope)
	}
	// Release nested logRecords recursively to their pool.
	logRecordPool.ReleaseSlice(elem.logRecords)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.scope = nil
	elem.logRecords = elem.logRecords[:0]
	elem.schemaUrl = ""

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== InstrumentationScope message implementation ======================

type InstrumentationScope struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_InstrumentationScope

	name                   string
	version                string
	attributes             []*KeyValue
	droppedAttributesCount uint32
}

func UnmarshalInstrumentationScope(bytes []byte, opts lazyproto.UnmarshalOpts) (*InstrumentationScope, error) {
	if opts.WithValidate {
		if err := validateInstrumentationScope(bytes); err != nil {
			return nil, err
		}
	}

	m := instrumentationScopePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *InstrumentationScope) Free() {
	instrumentationScopePool.Release(m)
}

// flags_InstrumentationScope is the type of the bit flags.
type flags_InstrumentationScope uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_InstrumentationScope_Attributes_Decoded flags_InstrumentationScope = 0x1

// Name returns the value of the name.
func (m *InstrumentationScope) Name() (r string) {
	return m.name
}

// SetName sets the value of the name.
func (m *InstrumentationScope) SetName(v string) {
	m.name = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Version returns the value of the version.
func (m *InstrumentationScope) Version() (r string) {
	return m.version
}

// SetVersion sets the value of the version.
func (m *InstrumentationScope) SetVersion(v string) {
	m.version = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Attributes returns the value of the attributes.
func (m *InstrumentationScope) Attributes() (r []*KeyValue) {
	if m._flags&flags_InstrumentationScope_Attributes_Decoded == 0 {
		m.decodeAttributes()
	}
	return m.attributes
}

// This is noinline, so that Attributes() is inlined instead.
//go:noinline
func (m *InstrumentationScope) decodeAttributes() {
	// Decode nested message(s).
	for i := range m.attributes {
		// TODO: decide how to handle decoding errors.
		_ = m.attributes[i].decode()
	}
	m._flags |= flags_InstrumentationScope_Attributes_Decoded
}

// SetAttributes sets the value of the attributes.
func (m *InstrumentationScope) SetAttributes(v []*KeyValue) {
	m.attributes = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.attributes {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *InstrumentationScope) AttributesRemoveIf(f func(*KeyValue) bool) {
	// Call getter to load the field.
	m.Attributes()

	newLen := 0
	for i := 0; i < len(m.attributes); i++ {
		if f(m.attributes[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.attributes[newLen] != nil {
			m.attributes[newLen].Free()
		}
		m.attributes[newLen] = m.attributes[i]
		m.attributes[i] = nil
		newLen++
	}
	if newLen != len(m.attributes) {
		m.attributes = m.attributes[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

// DroppedAttributesCount returns the value of the droppedAttributesCount.
func (m *InstrumentationScope) DroppedAttributesCount() (r uint32) {
	return m.droppedAttributesCount
}

// SetDroppedAttributesCount sets the value of the droppedAttributesCount.
func (m *InstrumentationScope) SetDroppedAttributesCount(v uint32) {
	m.droppedAttributesCount = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateInstrumentationScope(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (name), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0010_010: // field number 2 (version), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0011_010: // field number 3 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateKeyValue(v)
			if err != nil {
				return err
			}
		case 0b0_0100_000: // field number 4 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			_, err := buf.AsUint32()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *InstrumentationScope) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	attributesCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (name), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_0010_010: // field number 2 (version), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_0011_010: // field number 3 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			attributesCount++
			buf.SkipRawBytes()
		case 0b0_0100_000: // field number 4 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			buf.SkipVarint()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.attributes) < attributesCount {
		// Need new space.
		m.attributes = make([]*KeyValue, attributesCount)
	} else {
		// Existing capacity is enough.
		m.attributes = m.attributes[0:attributesCount]
	}
	keyValuePool.GetSlice(m.attributes)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	attributesCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (name), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.name = v
		case 0b0_0010_010: // field number 2 (version), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.version = v
		case 0b0_0011_010: // field number 3 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.attributes[attributesCount]
			attributesCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0100_000: // field number 4 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsUint32()
			if err != nil {
				return err
			}
			m.droppedAttributesCount = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_InstrumentationScope_Name = molecule.PrepareStringField(1)
var prepared_InstrumentationScope_Version = molecule.PrepareStringField(2)
var prepared_InstrumentationScope_Attributes = molecule.PrepareEmbeddedField(3)
var prepared_InstrumentationScope_DroppedAttributesCount = molecule.PrepareUint32Field(4)

func (m *InstrumentationScope) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "name".
		ps.StringPrepared(prepared_InstrumentationScope_Name, m.name)
		// Marshal "version".
		ps.StringPrepared(prepared_InstrumentationScope_Version, m.version)
		// Marshal "attributes".
		for _, elem := range m.attributes {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_InstrumentationScope_Attributes)
		}
		// Marshal "droppedAttributesCount".
		ps.Uint32Prepared(prepared_InstrumentationScope_DroppedAttributesCount, m.droppedAttributesCount)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of InstrumentationScope structs.
type instrumentationScopePoolType struct {
	pool []*InstrumentationScope
	mux  sync.Mutex
}

var instrumentationScopePool = instrumentationScopePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *instrumentationScopePoolType) Get() *InstrumentationScope {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &InstrumentationScope{}
}

func (p *instrumentationScopePoolType) GetSlice(r []*InstrumentationScope) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]InstrumentationScope, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *instrumentationScopePoolType) ReleaseSlice(slice []*InstrumentationScope) {
	for _, elem := range slice {
		// Release nested attributes recursively to their pool.
		keyValuePool.ReleaseSlice(elem.attributes)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.name = ""
		elem.version = ""
		elem.attributes = elem.attributes[:0]
		elem.droppedAttributesCount = 0
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *instrumentationScopePoolType) Release(elem *InstrumentationScope) {
	// Release nested attributes recursively to their pool.
	keyValuePool.ReleaseSlice(elem.attributes)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.name = ""
	elem.version = ""
	elem.attributes = elem.attributes[:0]
	elem.droppedAttributesCount = 0

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== LogRecord message implementation ======================

type LogRecord struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_LogRecord

	timeUnixNano           uint64
	observedTimeUnixNano   uint64
	severityNumber         SeverityNumber
	severityText           string
	attributes             []*KeyValue
	droppedAttributesCount uint32
	flags                  uint32
	traceId                []byte
	spanId                 []byte
}

func UnmarshalLogRecord(bytes []byte, opts lazyproto.UnmarshalOpts) (*LogRecord, error) {
	if opts.WithValidate {
		if err := validateLogRecord(bytes); err != nil {
			return nil, err
		}
	}

	m := logRecordPool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *LogRecord) Free() {
	logRecordPool.Release(m)
}

// flags_LogRecord is the type of the bit flags.
type flags_LogRecord uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_LogRecord_Attributes_Decoded flags_LogRecord = 0x1

// TimeUnixNano returns the value of the timeUnixNano.
func (m *LogRecord) TimeUnixNano() (r uint64) {
	return m.timeUnixNano
}

// SetTimeUnixNano sets the value of the timeUnixNano.
func (m *LogRecord) SetTimeUnixNano(v uint64) {
	m.timeUnixNano = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// ObservedTimeUnixNano returns the value of the observedTimeUnixNano.
func (m *LogRecord) ObservedTimeUnixNano() (r uint64) {
	return m.observedTimeUnixNano
}

// SetObservedTimeUnixNano sets the value of the observedTimeUnixNano.
func (m *LogRecord) SetObservedTimeUnixNano(v uint64) {
	m.observedTimeUnixNano = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// SeverityNumber returns the value of the severityNumber.
func (m *LogRecord) SeverityNumber() (r SeverityNumber) {
	return m.severityNumber
}

// SetSeverityNumber sets the value of the severityNumber.
func (m *LogRecord) SetSeverityNumber(v SeverityNumber) {
	m.severityNumber = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// SeverityText returns the value of the severityText.
func (m *LogRecord) SeverityText() (r string) {
	return m.severityText
}

// SetSeverityText sets the value of the severityText.
func (m *LogRecord) SetSeverityText(v string) {
	m.severityText = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Attributes returns the value of the attributes.
func (m *LogRecord) Attributes() (r []*KeyValue) {
	if m._flags&flags_LogRecord_Attributes_Decoded == 0 {
		m.decodeAttributes()
	}
	return m.attributes
}

// This is noinline, so that Attributes() is inlined instead.
//go:noinline
func (m *LogRecord) decodeAttributes() {
	// Decode nested message(s).
	for i := range m.attributes {
		// TODO: decide how to handle decoding errors.
		_ = m.attributes[i].decode()
	}
	m._flags |= flags_LogRecord_Attributes_Decoded
}

// SetAttributes sets the value of the attributes.
func (m *LogRecord) SetAttributes(v []*KeyValue) {
	m.attributes = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.attributes {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *LogRecord) AttributesRemoveIf(f func(*KeyValue) bool) {
	// Call getter to load the field.
	m.Attributes()

	newLen := 0
	for i := 0; i < len(m.attributes); i++ {
		if f(m.attributes[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.attributes[newLen] != nil {
			m.attributes[newLen].Free()
		}
		m.attributes[newLen] = m.attributes[i]
		m.attributes[i] = nil
		newLen++
	}
	if newLen != len(m.attributes) {
		m.attributes = m.attributes[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

// DroppedAttributesCount returns the value of the droppedAttributesCount.
func (m *LogRecord) DroppedAttributesCount() (r uint32) {
	return m.droppedAttributesCount
}

// SetDroppedAttributesCount sets the value of the droppedAttributesCount.
func (m *LogRecord) SetDroppedAttributesCount(v uint32) {
	m.droppedAttributesCount = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Flags returns the value of the flags.
func (m *LogRecord) Flags() (r uint32) {
	return m.flags
}

// SetFlags sets the value of the flags.
func (m *LogRecord) SetFlags(v uint32) {
	m.flags = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// TraceId returns the value of the traceId.
func (m *LogRecord) TraceId() (r []byte) {
	return m.traceId
}

// SetTraceId sets the value of the traceId.
func (m *LogRecord) SetTraceId(v []byte) {
	m.traceId = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// SpanId returns the value of the spanId.
func (m *LogRecord) SpanId() (r []byte) {
	return m.spanId
}

// SetSpanId sets the value of the spanId.
func (m *LogRecord) SetSpanId(v []byte) {
	m.spanId = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateLogRecord(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_001: // field number 1 (timeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			_, err := buf.AsFixed64()
			if err != nil {
				return err
			}
		case 0b0_1011_001: // field number 11 (observedTimeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			_, err := buf.AsFixed64()
			if err != nil {
				return err
			}
		case 0b0_0010_000: // field number 2 (severityNumber), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsUint32()
			if err != nil {
				return err
			}
			_ = v
		case 0b0_0011_010: // field number 3 (severityText), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0110_010: // field number 6 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateKeyValue(v)
			if err != nil {
				return err
			}
		case 0b0_0111_000: // field number 7 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			_, err := buf.AsUint32()
			if err != nil {
				return err
			}
		case 0b0_1000_101: // field number 8 (flags), wire type 5 (Fixed32)
			buf.SkipByteUnsafe()
			_, err := buf.AsFixed32()
			if err != nil {
				return err
			}
		case 0b0_1001_010: // field number 9 (traceId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_1010_010: // field number 10 (spanId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *LogRecord) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	attributesCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_001: // field number 1 (timeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			buf.SkipFixed64()
		case 0b0_1011_001: // field number 11 (observedTimeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			buf.SkipFixed64()
		case 0b0_0010_000: // field number 2 (severityNumber), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			buf.SkipVarint()
		case 0b0_0011_010: // field number 3 (severityText), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_0110_010: // field number 6 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			attributesCount++
			buf.SkipRawBytes()
		case 0b0_0111_000: // field number 7 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			buf.SkipVarint()
		case 0b0_1000_101: // field number 8 (flags), wire type 5 (Fixed32)
			buf.SkipByteUnsafe()
			buf.SkipFixed32()
		case 0b0_1001_010: // field number 9 (traceId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		case 0b0_1010_010: // field number 10 (spanId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.attributes) < attributesCount {
		// Need new space.
		m.attributes = make([]*KeyValue, attributesCount)
	} else {
		// Existing capacity is enough.
		m.attributes = m.attributes[0:attributesCount]
	}
	keyValuePool.GetSlice(m.attributes)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	attributesCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_001: // field number 1 (timeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			v, err := buf.AsFixed64()
			if err != nil {
				return err
			}
			m.timeUnixNano = v
		case 0b0_1011_001: // field number 11 (observedTimeUnixNano), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			v, err := buf.AsFixed64()
			if err != nil {
				return err
			}
			m.observedTimeUnixNano = v
		case 0b0_0010_000: // field number 2 (severityNumber), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsUint32()
			if err != nil {
				return err
			}
			m.severityNumber = SeverityNumber(v)
		case 0b0_0011_010: // field number 3 (severityText), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.severityText = v
		case 0b0_0110_010: // field number 6 (attributes), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.attributes[attributesCount]
			attributesCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		case 0b0_0111_000: // field number 7 (droppedAttributesCount), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsUint32()
			if err != nil {
				return err
			}
			m.droppedAttributesCount = v
		case 0b0_1000_101: // field number 8 (flags), wire type 5 (Fixed32)
			buf.SkipByteUnsafe()
			v, err := buf.AsFixed32()
			if err != nil {
				return err
			}
			m.flags = v
		case 0b0_1001_010: // field number 9 (traceId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}
			m.traceId = v
		case 0b0_1010_010: // field number 10 (spanId), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}
			m.spanId = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_LogRecord_TimeUnixNano = molecule.PrepareFixed64Field(1)
var prepared_LogRecord_ObservedTimeUnixNano = molecule.PrepareFixed64Field(11)
var prepared_LogRecord_SeverityNumber = molecule.PrepareUint32Field(2)
var prepared_LogRecord_SeverityText = molecule.PrepareStringField(3)
var prepared_LogRecord_Attributes = molecule.PrepareEmbeddedField(6)
var prepared_LogRecord_DroppedAttributesCount = molecule.PrepareUint32Field(7)
var prepared_LogRecord_Flags = molecule.PrepareFixed32Field(8)
var prepared_LogRecord_TraceId = molecule.PrepareBytesField(9)
var prepared_LogRecord_SpanId = molecule.PrepareBytesField(10)

func (m *LogRecord) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "timeUnixNano".
		ps.Fixed64Prepared(prepared_LogRecord_TimeUnixNano, m.timeUnixNano)
		// Marshal "severityNumber".
		ps.Uint32Prepared(prepared_LogRecord_SeverityNumber, uint32(m.severityNumber))
		// Marshal "severityText".
		ps.StringPrepared(prepared_LogRecord_SeverityText, m.severityText)
		// Marshal "attributes".
		for _, elem := range m.attributes {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_LogRecord_Attributes)
		}
		// Marshal "droppedAttributesCount".
		ps.Uint32Prepared(prepared_LogRecord_DroppedAttributesCount, m.droppedAttributesCount)
		// Marshal "flags".
		ps.Fixed32Prepared(prepared_LogRecord_Flags, m.flags)
		// Marshal "traceId".
		ps.BytesPrepared(prepared_LogRecord_TraceId, m.traceId)
		// Marshal "spanId".
		ps.BytesPrepared(prepared_LogRecord_SpanId, m.spanId)
		// Marshal "observedTimeUnixNano".
		ps.Fixed64Prepared(prepared_LogRecord_ObservedTimeUnixNano, m.observedTimeUnixNano)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of LogRecord structs.
type logRecordPoolType struct {
	pool []*LogRecord
	mux  sync.Mutex
}

var logRecordPool = logRecordPoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *logRecordPoolType) Get() *LogRecord {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &LogRecord{}
}

func (p *logRecordPoolType) GetSlice(r []*LogRecord) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]LogRecord, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *logRecordPoolType) ReleaseSlice(slice []*LogRecord) {
	for _, elem := range slice {
		// Release nested attributes recursively to their pool.
		keyValuePool.ReleaseSlice(elem.attributes)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.timeUnixNano = 0
		elem.observedTimeUnixNano = 0
		elem.severityNumber = SeverityNumber(0)
		elem.severityText = ""
		elem.attributes = elem.attributes[:0]
		elem.droppedAttributesCount = 0
		elem.flags = 0
		elem.traceId = nil
		elem.spanId = nil
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *logRecordPoolType) Release(elem *LogRecord) {
	// Release nested attributes recursively to their pool.
	keyValuePool.ReleaseSlice(elem.attributes)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.timeUnixNano = 0
	elem.observedTimeUnixNano = 0
	elem.severityNumber = SeverityNumber(0)
	elem.severityText = ""
	elem.attributes = elem.attributes[:0]
	elem.droppedAttributesCount = 0
	elem.flags = 0
	elem.traceId = nil
	elem.spanId = nil

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== KeyValue message implementation ======================

type KeyValue struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_KeyValue

	key   string
	value *AnyValue
}

func UnmarshalKeyValue(bytes []byte, opts lazyproto.UnmarshalOpts) (*KeyValue, error) {
	if opts.WithValidate {
		if err := validateKeyValue(bytes); err != nil {
			return nil, err
		}
	}

	m := keyValuePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *KeyValue) Free() {
	keyValuePool.Release(m)
}

// flags_KeyValue is the type of the bit flags.
type flags_KeyValue uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_KeyValue_Value_Decoded flags_KeyValue = 0x1

// Key returns the value of the key.
func (m *KeyValue) Key() (r string) {
	return m.key
}

// SetKey sets the value of the key.
func (m *KeyValue) SetKey(v string) {
	m.key = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Value returns the value of the value.
func (m *KeyValue) Value() (r *AnyValue) {
	if m._flags&flags_KeyValue_Value_Decoded == 0 {
		m.decodeValue()
	}
	return m.value
}

// This is noinline, so that Value() is inlined instead.
//go:noinline
func (m *KeyValue) decodeValue() {
	// Decode nested message(s).
	value := m.value
	if value != nil {
		// TODO: decide how to handle decoding errors.
		_ = value.decode()
	}
	m._flags |= flags_KeyValue_Value_Decoded
}

// SetValue sets the value of the value.
func (m *KeyValue) SetValue(v *AnyValue) {
	m.value = v

	// Make sure the field's Parent points to this message.
	v._protoMessage.Parent = &m._protoMessage

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateKeyValue(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (key), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0010_010: // field number 2 (value), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateAnyValue(v)
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *KeyValue) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (key), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.key = v
		case 0b0_0010_010: // field number 2 (value), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			m.value = anyValuePool.Get()
			m.value._protoMessage.Parent = &m._protoMessage
			m.value._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_KeyValue_Key = molecule.PrepareStringField(1)
var prepared_KeyValue_Value = molecule.PrepareEmbeddedField(2)

func (m *KeyValue) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "key".
		ps.StringPrepared(prepared_KeyValue_Key, m.key)
		// Marshal "value".
		value := m.value
		if value != nil {
			token := ps.BeginEmbedded()
			if err := value.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_KeyValue_Value)
		}
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of KeyValue structs.
type keyValuePoolType struct {
	pool []*KeyValue
	mux  sync.Mutex
}

var keyValuePool = keyValuePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *keyValuePoolType) Get() *KeyValue {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &KeyValue{}
}

func (p *keyValuePoolType) GetSlice(r []*KeyValue) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]KeyValue, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *keyValuePoolType) ReleaseSlice(slice []*KeyValue) {
	for _, elem := range slice {
		// Release nested value recursively to their pool.
		if elem.value != nil {
			anyValuePool.Release(elem.value)
		}

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.key = ""
		elem.value = nil
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *keyValuePoolType) Release(elem *KeyValue) {
	// Release nested value recursively to their pool.
	if elem.value != nil {
		anyValuePool.Release(elem.value)
	}

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.key = ""
	elem.value = nil

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== AnyValue message implementation ======================

type AnyValue struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_AnyValue

	value oneof.OneOf
}

func UnmarshalAnyValue(bytes []byte, opts lazyproto.UnmarshalOpts) (*AnyValue, error) {
	if opts.WithValidate {
		if err := validateAnyValue(bytes); err != nil {
			return nil, err
		}
	}

	m := anyValuePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *AnyValue) Free() {
	anyValuePool.Release(m)
}

// AnyValueValue defines the possible types for oneof field "value".
type AnyValueValue int

const (
	// AnyValueValueNone indicates that none of the oneof choices is set.
	AnyValueValueNone AnyValueValue = 0
	// AnyValueStringValue indicates that oneof field "stringValue" is set.
	AnyValueStringValue AnyValueValue = 1
	// AnyValueBoolValue indicates that oneof field "boolValue" is set.
	AnyValueBoolValue AnyValueValue = 2
	// AnyValueIntValue indicates that oneof field "intValue" is set.
	AnyValueIntValue AnyValueValue = 3
	// AnyValueDoubleValue indicates that oneof field "doubleValue" is set.
	AnyValueDoubleValue AnyValueValue = 4
	// AnyValueArrayValue indicates that oneof field "arrayValue" is set.
	AnyValueArrayValue AnyValueValue = 5
	// AnyValueKvlistValue indicates that oneof field "kvlistValue" is set.
	AnyValueKvlistValue AnyValueValue = 6
	// AnyValueBytesValue indicates that oneof field "bytesValue" is set.
	AnyValueBytesValue AnyValueValue = 7
)

// ValueType returns the type of the current stored oneof "value".
// To set the type use one of the setters.
func (m *AnyValue) ValueType() AnyValueValue {
	return AnyValueValue(m.value.FieldIndex())
}

// ValueUnset unsets the oneof field "value", so that it contains none of the choices.
func (m *AnyValue) ValueUnset() {
	m.value = oneof.NewNone()
}

// flags_AnyValue is the type of the bit flags.
type flags_AnyValue uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_AnyValue_ArrayValue_Decoded flags_AnyValue = 0x1
const flags_AnyValue_KvlistValue_Decoded flags_AnyValue = 0x2

// StringValue returns the value of the stringValue.
// If the field "value" is not set to "stringValue" then the returned value is undefined.
func (m *AnyValue) StringValue() (r string) {
	if m.value.FieldIndex() == int(AnyValueStringValue) {
		return m.value.StringVal()
	}
	return
}

// SetStringValue sets the value of the stringValue.
// The oneof field "value" will be set to "stringValue".
func (m *AnyValue) SetStringValue(v string) {
	m.value = oneof.NewString(v, int(AnyValueStringValue))

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// BoolValue returns the value of the boolValue.
// If the field "value" is not set to "boolValue" then the returned value is undefined.
func (m *AnyValue) BoolValue() (r bool) {
	if m.value.FieldIndex() == int(AnyValueBoolValue) {
		return m.value.BoolVal()
	}
	return
}

// SetBoolValue sets the value of the boolValue.
// The oneof field "value" will be set to "boolValue".
func (m *AnyValue) SetBoolValue(v bool) {
	m.value = oneof.NewBool(v, int(AnyValueBoolValue))

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// IntValue returns the value of the intValue.
// If the field "value" is not set to "intValue" then the returned value is undefined.
func (m *AnyValue) IntValue() (r int64) {
	if m.value.FieldIndex() == int(AnyValueIntValue) {
		return m.value.Int64Val()
	}
	return
}

// SetIntValue sets the value of the intValue.
// The oneof field "value" will be set to "intValue".
func (m *AnyValue) SetIntValue(v int64) {
	m.value = oneof.NewInt64(v, int(AnyValueIntValue))

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// DoubleValue returns the value of the doubleValue.
// If the field "value" is not set to "doubleValue" then the returned value is undefined.
func (m *AnyValue) DoubleValue() (r float64) {
	if m.value.FieldIndex() == int(AnyValueDoubleValue) {
		return m.value.DoubleVal()
	}
	return
}

// SetDoubleValue sets the value of the doubleValue.
// The oneof field "value" will be set to "doubleValue".
func (m *AnyValue) SetDoubleValue(v float64) {
	m.value = oneof.NewDouble(v, int(AnyValueDoubleValue))

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// ArrayValue returns the value of the arrayValue.
// If the field "value" is not set to "arrayValue" then the returned value is undefined.
func (m *AnyValue) ArrayValue() (r *ArrayValue) {
	if m._flags&flags_AnyValue_ArrayValue_Decoded == 0 {
		m.decodeArrayValue()
	}
	if m.value.FieldIndex() == int(AnyValueArrayValue) {
		return (*ArrayValue)(m.value.PtrVal())
	}
	return nil
}

// This is noinline, so that ArrayValue() is inlined instead.
//go:noinline
func (m *AnyValue) decodeArrayValue() {
	// Decode nested message(s).
	if m.value.FieldIndex() == int(AnyValueArrayValue) {
		arrayValue := (*ArrayValue)(m.value.PtrVal())
		if arrayValue != nil {
			// TODO: decide how to handle decoding errors.
			_ = arrayValue.decode()
		}
	}
	m._flags |= flags_AnyValue_ArrayValue_Decoded
}

// SetArrayValue sets the value of the arrayValue.
// The oneof field "value" will be set to "arrayValue".
func (m *AnyValue) SetArrayValue(v *ArrayValue) {
	m.value = oneof.NewPtr(unsafe.Pointer(v), int(AnyValueArrayValue))

	// Make sure the field's Parent points to this message.
	v._protoMessage.Parent = &m._protoMessage

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// KvlistValue returns the value of the kvlistValue.
// If the field "value" is not set to "kvlistValue" then the returned value is undefined.
func (m *AnyValue) KvlistValue() (r *KeyValueList) {
	if m._flags&flags_AnyValue_KvlistValue_Decoded == 0 {
		m.decodeKvlistValue()
	}
	if m.value.FieldIndex() == int(AnyValueKvlistValue) {
		return (*KeyValueList)(m.value.PtrVal())
	}
	return nil
}

// This is noinline, so that KvlistValue() is inlined instead.
//go:noinline
func (m *AnyValue) decodeKvlistValue() {
	// Decode nested message(s).
	if m.value.FieldIndex() == int(AnyValueKvlistValue) {
		kvlistValue := (*KeyValueList)(m.value.PtrVal())
		if kvlistValue != nil {
			// TODO: decide how to handle decoding errors.
			_ = kvlistValue.decode()
		}
	}
	m._flags |= flags_AnyValue_KvlistValue_Decoded
}

// SetKvlistValue sets the value of the kvlistValue.
// The oneof field "value" will be set to "kvlistValue".
func (m *AnyValue) SetKvlistValue(v *KeyValueList) {
	m.value = oneof.NewPtr(unsafe.Pointer(v), int(AnyValueKvlistValue))

	// Make sure the field's Parent points to this message.
	v._protoMessage.Parent = &m._protoMessage

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// BytesValue returns the value of the bytesValue.
// If the field "value" is not set to "bytesValue" then the returned value is undefined.
func (m *AnyValue) BytesValue() (r []byte) {
	if m.value.FieldIndex() == int(AnyValueBytesValue) {
		return m.value.BytesVal()
	}
	return
}

// SetBytesValue sets the value of the bytesValue.
// The oneof field "value" will be set to "bytesValue".
func (m *AnyValue) SetBytesValue(v []byte) {
	m.value = oneof.NewBytes(v, int(AnyValueBytesValue))

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validateAnyValue(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (stringValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0010_000: // field number 2 (boolValue), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			_, err := buf.AsBool()
			if err != nil {
				return err
			}
		case 0b0_0011_000: // field number 3 (intValue), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			_, err := buf.AsInt64()
			if err != nil {
				return err
			}
		case 0b0_0100_001: // field number 4 (doubleValue), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			_, err := buf.AsDouble()
			if err != nil {
				return err
			}
		case 0b0_0101_010: // field number 5 (arrayValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateArrayValue(v)
			if err != nil {
				return err
			}
		case 0b0_0110_010: // field number 6 (kvlistValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateKeyValueList(v)
			if err != nil {
				return err
			}
		case 0b0_0111_010: // field number 7 (bytesValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *AnyValue) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (stringValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.value = oneof.NewString(v, int(AnyValueStringValue))
		case 0b0_0010_000: // field number 2 (boolValue), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsBool()
			if err != nil {
				return err
			}
			m.value = oneof.NewBool(v, int(AnyValueBoolValue))
		case 0b0_0011_000: // field number 3 (intValue), wire type 0 (Varint)
			buf.SkipByteUnsafe()
			v, err := buf.AsInt64()
			if err != nil {
				return err
			}
			m.value = oneof.NewInt64(v, int(AnyValueIntValue))
		case 0b0_0100_001: // field number 4 (doubleValue), wire type 1 (Fixed64)
			buf.SkipByteUnsafe()
			v, err := buf.AsDouble()
			if err != nil {
				return err
			}
			m.value = oneof.NewDouble(v, int(AnyValueDoubleValue))
		case 0b0_0101_010: // field number 5 (arrayValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			elem := arrayValuePool.Get()
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
			m.value = oneof.NewPtr(unsafe.Pointer(elem), int(AnyValueArrayValue))
		case 0b0_0110_010: // field number 6 (kvlistValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			elem := keyValueListPool.Get()
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
			m.value = oneof.NewPtr(unsafe.Pointer(elem), int(AnyValueKvlistValue))
		case 0b0_0111_010: // field number 7 (bytesValue), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}
			m.value = oneof.NewBytes(v, int(AnyValueBytesValue))
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_AnyValue_StringValue = molecule.PrepareStringField(1)
var prepared_AnyValue_BoolValue = molecule.PrepareBoolField(2)
var prepared_AnyValue_IntValue = molecule.PrepareInt64Field(3)
var prepared_AnyValue_DoubleValue = molecule.PrepareDoubleField(4)
var prepared_AnyValue_ArrayValue = molecule.PrepareEmbeddedField(5)
var prepared_AnyValue_KvlistValue = molecule.PrepareEmbeddedField(6)
var prepared_AnyValue_BytesValue = molecule.PrepareBytesField(7)

func (m *AnyValue) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "value".
		// Switch on the type of the value stored in the oneof field.
		switch AnyValueValue(m.value.FieldIndex()) {
		case AnyValueValueNone:
			// Nothing to do, oneof is unset.
		case AnyValueStringValue:
			// Marshal "stringValue".
			ps.StringPrepared(prepared_AnyValue_StringValue, m.value.StringVal())
		case AnyValueBoolValue:
			// Marshal "boolValue".
			ps.BoolPrepared(prepared_AnyValue_BoolValue, m.value.BoolVal())
		case AnyValueIntValue:
			// Marshal "intValue".
			ps.Int64Prepared(prepared_AnyValue_IntValue, m.value.Int64Val())
		case AnyValueDoubleValue:
			// Marshal "doubleValue".
			ps.DoublePrepared(prepared_AnyValue_DoubleValue, m.value.DoubleVal())
		case AnyValueArrayValue:
			// Marshal "arrayValue".
			arrayValue := (*ArrayValue)(m.value.PtrVal())
			if arrayValue != nil {
				token := ps.BeginEmbedded()
				if err := arrayValue.Marshal(ps); err != nil {
					return err
				}
				ps.EndEmbeddedPrepared(token, prepared_AnyValue_ArrayValue)
			}
		case AnyValueKvlistValue:
			// Marshal "kvlistValue".
			kvlistValue := (*KeyValueList)(m.value.PtrVal())
			if kvlistValue != nil {
				token := ps.BeginEmbedded()
				if err := kvlistValue.Marshal(ps); err != nil {
					return err
				}
				ps.EndEmbeddedPrepared(token, prepared_AnyValue_KvlistValue)
			}
		case AnyValueBytesValue:
			// Marshal "bytesValue".
			ps.BytesPrepared(prepared_AnyValue_BytesValue, m.value.BytesVal())
		}
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of AnyValue structs.
type anyValuePoolType struct {
	pool []*AnyValue
	mux  sync.Mutex
}

var anyValuePool = anyValuePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *anyValuePoolType) Get() *AnyValue {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &AnyValue{}
}

func (p *anyValuePoolType) GetSlice(r []*AnyValue) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]AnyValue, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *anyValuePoolType) ReleaseSlice(slice []*AnyValue) {
	for _, elem := range slice {
		switch AnyValueValue(elem.value.FieldIndex()) {
		case AnyValueArrayValue:
			ptr := (*ArrayValue)(elem.value.PtrVal())
			if ptr != nil {
				arrayValuePool.Release(ptr)
			}
		case AnyValueKvlistValue:
			ptr := (*KeyValueList)(elem.value.PtrVal())
			if ptr != nil {
				keyValueListPool.Release(ptr)
			}
		}

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.value = oneof.NewNone()
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *anyValuePoolType) Release(elem *AnyValue) {
	switch AnyValueValue(elem.value.FieldIndex()) {
	case AnyValueArrayValue:
		ptr := (*ArrayValue)(elem.value.PtrVal())
		if ptr != nil {
			arrayValuePool.Release(ptr)
		}
	case AnyValueKvlistValue:
		ptr := (*KeyValueList)(elem.value.PtrVal())
		if ptr != nil {
			keyValueListPool.Release(ptr)
		}
	}

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.value = oneof.NewNone()

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== ArrayValue message implementation ======================

type ArrayValue struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_ArrayValue

	values []*AnyValue
}

func UnmarshalArrayValue(bytes []byte, opts lazyproto.UnmarshalOpts) (*ArrayValue, error) {
	if opts.WithValidate {
		if err := validateArrayValue(bytes); err != nil {
			return nil, err
		}
	}

	m := arrayValuePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ArrayValue) Free() {
	arrayValuePool.Release(m)
}

// flags_ArrayValue is the type of the bit flags.
type flags_ArrayValue uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_ArrayValue_Values_Decoded flags_ArrayValue = 0x1

// Values returns the value of the values.
func (m *ArrayValue) Values() (r []*AnyValue) {
	if m._flags&flags_ArrayValue_Values_Decoded == 0 {
		m.decodeValues()
	}
	return m.values
}

// This is noinline, so that Values() is inlined instead.
//go:noinline
func (m *ArrayValue) decodeValues() {
	// Decode nested message(s).
	for i := range m.values {
		// TODO: decide how to handle decoding errors.
		_ = m.values[i].decode()
	}
	m._flags |= flags_ArrayValue_Values_Decoded
}

// SetValues sets the value of the values.
func (m *ArrayValue) SetValues(v []*AnyValue) {
	m.values = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.values {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *ArrayValue) ValuesRemoveIf(f func(*AnyValue) bool) {
	// Call getter to load the field.
	m.Values()

	newLen := 0
	for i := 0; i < len(m.values); i++ {
		if f(m.values[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.values[newLen] != nil {
			m.values[newLen].Free()
		}
		m.values[newLen] = m.values[i]
		m.values[i] = nil
		newLen++
	}
	if newLen != len(m.values) {
		m.values = m.values[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

func validateArrayValue(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateAnyValue(v)
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *ArrayValue) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	valuesCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			valuesCount++
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.values) < valuesCount {
		// Need new space.
		m.values = make([]*AnyValue, valuesCount)
	} else {
		// Existing capacity is enough.
		m.values = m.values[0:valuesCount]
	}
	anyValuePool.GetSlice(m.values)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	valuesCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.values[valuesCount]
			valuesCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_ArrayValue_Values = molecule.PrepareEmbeddedField(1)

func (m *ArrayValue) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "values".
		for _, elem := range m.values {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_ArrayValue_Values)
		}
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of ArrayValue structs.
type arrayValuePoolType struct {
	pool []*ArrayValue
	mux  sync.Mutex
}

var arrayValuePool = arrayValuePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *arrayValuePoolType) Get() *ArrayValue {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &ArrayValue{}
}

func (p *arrayValuePoolType) GetSlice(r []*ArrayValue) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]ArrayValue, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *arrayValuePoolType) ReleaseSlice(slice []*ArrayValue) {
	for _, elem := range slice {
		// Release nested values recursively to their pool.
		anyValuePool.ReleaseSlice(elem.values)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.values = elem.values[:0]
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *arrayValuePoolType) Release(elem *ArrayValue) {
	// Release nested values recursively to their pool.
	anyValuePool.ReleaseSlice(elem.values)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.values = elem.values[:0]

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== KeyValueList message implementation ======================

type KeyValueList struct {
	_protoMessage protomessage.ProtoMessage
	_flags        flags_KeyValueList

	values []*KeyValue
}

func UnmarshalKeyValueList(bytes []byte, opts lazyproto.UnmarshalOpts) (*KeyValueList, error) {
	if opts.WithValidate {
		if err := validateKeyValueList(bytes); err != nil {
			return nil, err
		}
	}

	m := keyValueListPool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *KeyValueList) Free() {
	keyValueListPool.Release(m)
}

// flags_KeyValueList is the type of the bit flags.
type flags_KeyValueList uint8

// Bitmasks that indicate that the particular nested message is decoded.
const flags_KeyValueList_Values_Decoded flags_KeyValueList = 0x1

// Values returns the value of the values.
func (m *KeyValueList) Values() (r []*KeyValue) {
	if m._flags&flags_KeyValueList_Values_Decoded == 0 {
		m.decodeValues()
	}
	return m.values
}

// This is noinline, so that Values() is inlined instead.
//go:noinline
func (m *KeyValueList) decodeValues() {
	// Decode nested message(s).
	for i := range m.values {
		// TODO: decide how to handle decoding errors.
		_ = m.values[i].decode()
	}
	m._flags |= flags_KeyValueList_Values_Decoded
}

// SetValues sets the value of the values.
func (m *KeyValueList) SetValues(v []*KeyValue) {
	m.values = v

	// Make sure the field's Parent points to this message.
	for _, elem := range m.values {
		elem._protoMessage.Parent = &m._protoMessage
	}

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func (m *KeyValueList) ValuesRemoveIf(f func(*KeyValue) bool) {
	// Call getter to load the field.
	m.Values()

	newLen := 0
	for i := 0; i < len(m.values); i++ {
		if f(m.values[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		if m.values[newLen] != nil {
			m.values[newLen].Free()
		}
		m.values[newLen] = m.values[i]
		m.values[i] = nil
		newLen++
	}
	if newLen != len(m.values) {
		m.values = m.values[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}

func validateKeyValueList(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.DecodeRawBytes()
			if err != nil {
				return err
			}
			err = validateKeyValue(v)
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *KeyValueList) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Reset all "decoded" and "presence" flags.
	m._flags = 0

	// Count all repeated fields. We need one counter per field.
	valuesCount := 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			valuesCount++
			buf.SkipRawBytes()
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}

	// Pre-allocate slices for repeated fields.
	if cap(m.values) < valuesCount {
		// Need new space.
		m.values = make([]*KeyValue, valuesCount)
	} else {
		// Existing capacity is enough.
		m.values = m.values[0:valuesCount]
	}
	keyValuePool.GetSlice(m.values)

	// Reset the buffer to start iterating over the fields again
	buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	// Set slice indexes to 0 to begin iterating over repeated fields.
	valuesCount = 0
	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (values), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsBytesUnsafe()
			if err != nil {
				return err
			}

			// The slice is pre-allocated, assign to the appropriate index.
			elem := m.values[valuesCount]
			valuesCount++
			elem._protoMessage.Parent = &m._protoMessage
			elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_KeyValueList_Values = molecule.PrepareEmbeddedField(1)

func (m *KeyValueList) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "values".
		for _, elem := range m.values {
			token := ps.BeginEmbedded()
			if err := elem.Marshal(ps); err != nil {
				return err
			}
			ps.EndEmbeddedPrepared(token, prepared_KeyValueList_Values)
		}
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of KeyValueList structs.
type keyValueListPoolType struct {
	pool []*KeyValueList
	mux  sync.Mutex
}

var keyValueListPool = keyValueListPoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *keyValueListPoolType) Get() *KeyValueList {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &KeyValueList{}
}

func (p *keyValueListPoolType) GetSlice(r []*KeyValueList) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]KeyValueList, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *keyValueListPoolType) ReleaseSlice(slice []*KeyValueList) {
	for _, elem := range slice {
		// Release nested values recursively to their pool.
		keyValuePool.ReleaseSlice(elem.values)

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem._flags = 0
		elem.values = elem.values[:0]
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *keyValueListPoolType) Release(elem *KeyValueList) {
	// Release nested values recursively to their pool.
	keyValuePool.ReleaseSlice(elem.values)

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem._flags = 0
	elem.values = elem.values[:0]

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}

// ====================== PlainMessage message implementation ======================

type PlainMessage struct {
	_protoMessage protomessage.ProtoMessage

	key   string
	value string
}

func UnmarshalPlainMessage(bytes []byte, opts lazyproto.UnmarshalOpts) (*PlainMessage, error) {
	if opts.WithValidate {
		if err := validatePlainMessage(bytes); err != nil {
			return nil, err
		}
	}

	m := plainMessagePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *PlainMessage) Free() {
	plainMessagePool.Release(m)
}

// Key returns the value of the key.
func (m *PlainMessage) Key() (r string) {
	return m.key
}

// SetKey sets the value of the key.
func (m *PlainMessage) SetKey(v string) {
	m.key = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

// Value returns the value of the value.
func (m *PlainMessage) Value() (r string) {
	return m.value
}

// SetValue sets the value of the value.
func (m *PlainMessage) SetValue(v string) {
	m.value = v

	// Mark this message modified, if not already.
	m._protoMessage.MarkModified()
}

func validatePlainMessage(b []byte) error {
	buf := codec.NewBuffer(b)

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (key), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		case 0b0_0010_010: // field number 2 (value), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			err := buf.SkipRawBytes()
			if err != nil {
				return err
			}
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (m *PlainMessage) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))

	for !buf.EOF() {
		// We need to read a varint that represents the key that encodes the field number
		// and wire type. Speculate that the varint is one byte length and switch on it.
		// This is the hot path that is most common when field number is <= 15.
		b := buf.PeekByteUnsafe()
		switch b {
		case 0b0_0001_010: // field number 1 (key), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.key = v
		case 0b0_0010_010: // field number 2 (value), wire type 2 (Bytes)
			buf.SkipByteUnsafe()
			v, err := buf.AsStringUnsafe()
			if err != nil {
				return err
			}
			m.value = v
		default:
			// Our speculation was wrong. Do the full (slow) decoding.
			v, err := buf.DecodeVarint()
			if err != nil {
				return err
			}
			fieldNum, wireType, err := codec.AsTagAndWireType(v)
			if err != nil {
				return err
			}

			switch fieldNum {
			default:
				// Unknown field number.
				if err := buf.SkipFieldByWireType(wireType); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

var prepared_PlainMessage_Key = molecule.PrepareStringField(1)
var prepared_PlainMessage_Value = molecule.PrepareStringField(2)

func (m *PlainMessage) Marshal(ps *molecule.ProtoStream) error {
	if m._protoMessage.IsModified() {
		// The struct is modified, marshal from the struct fields.
		// Marshal "key".
		ps.StringPrepared(prepared_PlainMessage_Key, m.key)
		// Marshal "value".
		ps.StringPrepared(prepared_PlainMessage_Value, m.value)
	} else {
		// We have the original bytes and the message is unchanged. Use the original bytes.
		ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
	}
	return nil
}

// Pool of PlainMessage structs.
type plainMessagePoolType struct {
	pool []*PlainMessage
	mux  sync.Mutex
}

var plainMessagePool = plainMessagePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *plainMessagePoolType) Get() *PlainMessage {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &PlainMessage{}
}

func (p *plainMessagePoolType) GetSlice(r []*PlainMessage) {
	// Create a new slice.
	count := len(r)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]PlainMessage, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}
}

// ReleaseSlice releases a slice of elements back to the pool.
func (p *plainMessagePoolType) ReleaseSlice(slice []*PlainMessage) {
	for _, elem := range slice {

		// Reset the released element.
		elem._protoMessage = protomessage.ProtoMessage{}
		elem.key = ""
		elem.value = ""
	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}

// Release an element back to the pool.
func (p *plainMessagePoolType) Release(elem *PlainMessage) {

	// Reset the released element.
	elem._protoMessage = protomessage.ProtoMessage{}
	elem.key = ""
	elem.value = ""

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}
